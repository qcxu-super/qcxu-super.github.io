# 基础：贪心算法

贪心法：遵循某种规律，不断贪心的选取当前最优策略的算法设计方法

- 举个例子

有1元、5元、10元、20元、100元、200元的钞票无穷多张。一共需要支付X=628元，则最少需要多少张钞票？

- 规律

尽可能多的使用面额值较大的钞票。所以，628=200\*3+20\*1+5\*1+1\*3，一共需要3+1+1+3=8张

- 分析

1元、5元、10元、20元、100元、200元，任意面额是比自己小面额的倍数整数倍。所以若用较小面额钞票替换，一定需要更多的其他面额钞票。所以贪心算法的结果是全局最优解。如果增加7元面额，则贪心算法不成立。比如，X=14元。7元的问题可以用动态规划解决。

```cpp
#include <studio.h>

int main() {
	const int RMB[] = {200,100,20,10,5,1};
	const int NUM = 6; // count(ditinct RMB)
	int X = 628;
	int count = 0;
	for (int i=0; i<NUM; ++i) {
		int use = X / RMB[i];
		count += use;
		X -= RMB[i] * use;
		printf("需要面额为%d的%d张，剩余需要支付金额%d\n", RMB[i], use, X);
	}
	printf("总共需要%d张", count);
	return 0;
}
```


# 例1 [455分发饼干(easy) - 排序+贪心](https://leetcode-cn.com/problems/assign-cookies/) | [solution](https://github.com/qcxu-super/qcxu-super.github.io/blob/master/Leetcode/3_GreedyAlgorithm/455_AssignCookies.cpp)

```
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

#### 1. 规律
- 如果一块小饼干不能满足最小需求孩子，那么更大需求的孩子也不可能满足
- 如果一个孩子能被更小饼干满足，那么没必要用更大的饼干去满足。留着更大的饼干去满足需求因子更大的孩子
- 所以从需求因子小的孩子身上开始试。因为我们要的是满足的孩子尽可能多，那么把饼干8满足需求2的孩子和需求6的孩子，其实是一样的


#### 2. 解题思路
- 对饼干大小排序，对孩子需求排序。从小到大。
- 依次遍历所有饼干。只需要遍历一次。如果能满足当前孩子，那就满足了。如果不能满足当前孩子，那之后需求更大的孩子也不可能用这块饼干满足，所以这块饼干就废了
- 如果上一块饼干满足了孩子的需求，则下一块饼干，下一个孩子。如果上一块饼干没有满足孩子的需求，则下一块饼干，还是这个孩子
- 直到没有更多的饼干，或者没有更多的孩子




# 例2 摇摆序列（贪心）

# 例3 移除K个数字（栈+贪心）

# 例4 跳跃游戏（贪心）

# 例5 射击气球（排序+贪心）
  
# 例6 最优加油方法（堆+贪心）